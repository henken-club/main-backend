interface Node {
  id: ID!
}

interface Edge {
  cursor: String!
  node: Node!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Book implements Node & Content {
  id: ID!
}

interface Content {
  id: ID!
}

type BookEdge implements Edge {
  cursor: String!
  node: Node!
}

type BookSeries implements Node & Content {
  id: ID!
}

type BookSeriesEdge implements Edge {
  cursor: String!
  node: Node!
}

type Henken implements Node {
  id: ID!
  comment: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  content: ContentUnion!
  postedBy: User!
  postsTo: User!
  answer: Answer
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

union ContentUnion = Book | BookSeries

type HenkenEdge implements Edge {
  cursor: String!
  node: Henken!
}

type HenkenConnection implements Connection {
  edges: [HenkenEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

interface Connection {
  edges: [Edge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type FindHenkenPayload {
  henken: Henken
}

type Answer implements Node {
  id: ID!
  comment: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  henken: Henken!
}

type AnswerEdge implements Edge {
  cursor: String!
  node: Answer!
}

type AnswerConnection implements Connection {
  edges: [AnswerEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type User implements Node {
  id: ID!
  followees(first: Int, after: String, last: Int, before: String, orderBy: FollowingOrder!): FollowingConnection!
  followers(first: Int, after: String, last: Int, before: String, orderBy: FollowingOrder!): FollowingConnection!
  postsHenkens(first: Int, after: String, last: Int, before: String, orderBy: HenkenOrder!): HenkenConnection!
  receivedHenkens(first: Int, after: String, last: Int, before: String, orderBy: HenkenOrder!): HenkenConnection!
  postsAnswers(first: Int, after: String, last: Int, before: String, orderBy: AnswerOrder!): AnswerConnection!
  receivedAnswers(first: Int, after: String, last: Int, before: String, orderBy: AnswerOrder!): AnswerConnection!
}

input FollowingOrder {
  direction: OrderDirection!
  field: FollowingOrderField!
}

enum OrderDirection {
  ASC
  DESC
}

enum FollowingOrderField {
  CREATED_AT
}

input HenkenOrder {
  direction: OrderDirection!
  field: HenkenOrderField!
}

enum HenkenOrderField {
  CREATED_AT
  UPDATED_AT
}

input AnswerOrder {
  direction: OrderDirection!
  field: AnswerOrderField!
}

enum AnswerOrderField {
  CREATED_AT
  UPDATED_AT
}

type FindAnswerPayload {
  henken: Answer
}

type FindUserPayload {
  user: User
}

type Following implements Node {
  id: ID!
  from: User!
  to: User!
}

type FollowingEdge implements Edge {
  cursor: String!
  node: Following!
}

type FollowingConnection implements Connection {
  edges: [FollowingEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Query {
  answer(id: ID!): Answer!
  findAnswer(id: ID!): FindAnswerPayload!
  henken(id: ID!): Henken!
  findHenken(id: ID!): FindHenkenPayload!
  user(id: ID!): User!
  findUser(id: ID!): FindUserPayload!
}
